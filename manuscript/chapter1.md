# Введение в React

В этой главе даётся введение в React. Вы можете спросить себя: почему я должен изучить React в первую очередь? Эта глава пытается ответить на этот вопрос. После этого вы погрузитесь в экосистему, создав ваше первое React-приложение без какой-либо конфигурации. По ходу дела вы познакомитесь с JSX и ReactDOM. Поэтому будьте готовы к вашим первым компонентам React.

## Привет, меня зовут React.

**Зачем вам нужно изучать React?** В последние годы популярные одностраничные приложения ([single-page application, SPA](https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)). Фреймворки, такие как Angular, Ember и Backbone, помогли разработчикам JavaScript создавать современные веб-приложения за пределами использования чистого (ванильного) JavaScript и jQuery. Список этих популярных решений далеко не полный. Существует широкий круг фреймворков для создания SPA. Если посмотреть на даты релизов, то большинство из них относятся к первому поколению SPA: Angular 2010, Backbone 2010 и Ember 2011.

React был изначально выпущен Facebook в 2013 году. React — это не SPA-фреймворк, а библиотека для разработки пользовательских интерфейсов (UI). Это только представление, буква V в аббревиатуре [MVC](https://ru.wikipedia.org/wiki/Model-View-Controller) (Model View Controller), то есть она предоставляет только уровень представления. Она позволяет вам только отрисовывать (render) компоненты в качестве видимых элементов в браузере. Однако вся экосистемы вокруг React позволяет создавать одностраничные приложения.

Но почему вы должны рассмотреть использование React, а не первое поколение SPA-фреймворков? В то время как первое поколение фреймворков пыталось решить сразу много всего, React используется только для создания слоя представления. Это библиотека, а не фреймворк. Идея React заключается в том, что ваше представление представляет собой иерархию составных компонентов.

В React вы можете сосредоточиться на своём слое представления, перед тем как внедрять остальные концепции в приложение. Каждый другой аспект — это ещё один строительный блок вашего SPA-приложения. Эти строительные блоки необходимы для создания зрелого приложения, и у них есть два преимущества.

Во-первых, вы можете изучать строительные блоки по одному, не понимая их вообще.
Напротив SPA даёт вам каждый строительный блок с самого начала. В этой книге основное внимание уделяется React как первому строительному блоку. В дальнейшем последуют всё больше строительных блоков.

Во-вторых, все строительные блоки взаимозаменяемы, что делает экосистему React очень инновационной. Несколько решений конкурируют друг с другом, и вы можете выбрать наиболее привлекательное решение для вас и вашего варианта использования.

Первое поколение SPA-фреймворков достигло промышленного уровня; такие фреймворки менее гибкие. React остаётся инновационным и используется многими технологическими компаниями-лидерами, такими как [Airbnb, Netflix и, конечно же, Facebook](https://github.com/facebook/react/wiki/Sites-Using-React). Все они инвестируют в будущее React и довольствуются React и его экосистемой.

React — один из лучших выборов для создания современных веб-приложений в настоящее время. Он обеспечивает только уровень представления, [но экосистема React представляет собой гибкий и взаимозаменяемый фреймворк](https://www.robinwieruch.de/essential-react-libraries-framework/). React имеет небольшой API, удивительную экосистему и отличное сообщество. Вы можете прочитать о моём опыте, [почему я перешёл с Angular на React](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/). Я настоятельно рекомендую понять, почему вы выбрали React, а не другой фреймворк или библиотеку. В конце концов, каждый стремится узнать, куда приведёт нас React в ближайшие несколько лет.

### Упражнения

* прочитайте о том, [почему я перешёл с Angular на React](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/)
* прочитайте о [гибкой экосистеме React](https://www.robinwieruch.de/essential-react-libraries-framework/)
* прочитайте о том, [как изучать фреймворк](https://www.robinwieruch.de/how-to-learn-framework/)

## Требования

Какие требования для чтения этой книги? Прежде всего, вы должны быть знакомы с основами веб-разработки. Вы должны знать, как использовать HTML, CSS и JavaScript. Возможно, имеет смысл также знать, что такое означает термин [API](https://www.robinwieruch.de/what-is-an-api-javascript/), потому что вы будете использовать API в данной книге. Кроме того, я призываю вас вступить в официальную [группу в Slack](https://slack-the-road-to-learn-react.wieruch.com/) этой книги для получения помощи или чтобы помочь другим.

### Редактор и терминал

Как насчёт среды разработки? Вам понадобится работающий редактор или IDE, а также терминал (инструмент командной строки). Вы можете [последовать моему руководству по настройке](https://www.robinwieruch.de/developer-setup/). Он предназначен для пользователей MacOS, но вы также можете найти руководство по настройке для Windows. В целом, есть много статей, которые покажут вам, как наилучшим образом настроить окружение веб-разработки более изысканным способом для используемой вами ОС.

При желании вы можете использовать git для хранения своих проектов и отслеживания прогресса изучения в репозиториях на GitHub, выполняя упражнения этой в книге. Существует [небольшое руководство](https://www.robinwieruch.de/git-essential-commands/) по использованию этих инструментов. Но опять же, это не необязательно для книги и может стать сдерживающим фактором при изучении всего этого с нуля. Вы можете пропустить эту часть, если вы новичок в веб-разработке, чтобы сосредоточиться на основных частях, описанных в книге.

### Node and NPM

И последнее, но не менее важное: вам потребуется установка [node и npm](https://nodejs.org/en/). Оба они используются для управления библиотеками, которые нам понадобятся по ходу дела. В этой книге вы будете устанавливать внешние node-пакеты через npm (node package manager). Эти node-пакеты могут быть библиотеками или целыми фреймворками.

Проверить версии node и npm можно в командной строке. Если вы не видите какой-либо вывод в терминале, вам сначала нужно установить node и npm. Ниже показаны только мои версии, которые я использовал во время написания книги:

{title="Command Line",lang="text"}
~~~~~~~~
node --version
*v8.9.4
npm --version
*v5.6.0
~~~~~~~~

## node and npm

В этой главе приведён небольшой обзор node и npm. Он не исчерпывающий, но даст вам все необходимые инструменты. Если вы знакомы с обоими из них, то вы можете пропустить этот раздел.

**Менеджер пакетов node** (node package manager, npm) позволяет устанавливать **node-пакеты (node packages)** из командной строки. Эти пакеты могут быть набором утилитарных функций, библиотеками или целыми фреймворками. Все они являются зависимостями вашего приложения. Вы можете установить все эти зависимости в папку с глобальными или локальными node-пакетами.

Глобальные node-пакеты доступны из любого места в терминале, и их необходимо установить только один раз в глобальный каталог. Вы можете установить глобальный пакет, введя в терминал:

{title="Command Line",lang="text"}
~~~~~~~~
npm install -g <package>
~~~~~~~~

Флаг `-g` сообщает npm установить пакет глобально. Локальные пакеты используются в вашем приложении. Например, React как библиотека будет локальным пакетом, которая требуется для работы вашего приложения. Вы можете установить его через терминал, набрав:

{title="Command Line",lang="text"}
~~~~~~~~
npm install <package>
~~~~~~~~

Команда установки React будет выглядит следующим образом:

{title="Command Line",lang="text"}
~~~~~~~~
npm install react
~~~~~~~~

Установленный пакет автоматически появится в папке *node_modules/* и будет перечислен в файле *package.json* вместе с другими зависимостями.

Но как инициализировать папку *node_modules/* и файл *package.json* для проекта в первую очередь? Для этого у нас есть команда npm, инициализирующая проект npm и, следовательно, файл *package.json*. После того, когда у вас есть этот файл, вы можете установить новые пакеты, используя npm.

{title="Command Line",lang="text"}
~~~~~~~~
npm init -y
~~~~~~~~

Флаг `-y` — ярлык для инициализации всех значений по умолчанию в *package.json*. Без использования этого флага, вам нужно самому решить, как сконфигурировать этот файл. После инициализации вашего npm-проекта вы готовы к установке новых пакетов через команду `npm install <package>`.

Ещё пару слов об *package.json*. Данный файл позволяет вам поделиться вашим проектом с другими разработчиками без передачи всех node-пакетов. Этот файл содержит все ссылки на пакеты node, используемые в вашем проекте. Эти пакеты называются зависимостями. Каждый может скопировать ваш проект без этих зависимостей. Зависимости — это ссылки в *package.json*. Кто-то, кто копирует ваш проект, может просто установить все пакеты, используя `npm install` в командной строке. Команда `npm install` возьмёт все зависимости, перечисленные в файле *package.json* и установит их в папку *node_modules/*.

Я хочу рассмотреть ещё одну npm-команду:

{title="Command Line",lang="text"}
~~~~~~~~
npm install --save-dev <package>
~~~~~~~~

Флаг `--save-dev` указывает, что node-пакет используется только в окружении разработки. Он не будет использоваться в продакшене при развёртывании вашего приложения на сервер. Какие node-пакеты должны устанавливаться с помощью этого флага? Представьте, что вы хотите протестировать приложение с помощью node-пакета. Вам нужно установить этот пакет через npm, но вы хотите исключить его из рабочего окружения. Тестирование должно происходить только в процессе разработки, а не тогда, когда приложение уже работает в продакшене. Там вам больше не нужно тестировать приложение. Приложение должно уже быть протестировано и работать из коробки для ваших пользователей. Это как раз тот случай, когда вы захотите использовать флаг `--save-dev`.

Вы столкнётесь с большим количеством npm-команд по ходу чтения, но этого пока будет достаточно.

### Упражнения:

* установка npm-проекта
  * создать каталог с помощью `mkdir <folder_name>`
  * перейти в каталог с помощью `cd <folder_name>`
  * выполнить `npm init -y` или `npm init`
  * установить локальный пакет React с помощью `npm install react`
  * посмотрите файл *package.json* и каталог *node_modules/*
  * выяснить самостоятельно, как удалить node-пакет *react*
* узнать больше о [npm](https://docs.npmjs.com/)

## Установка

Существует несколько подходов начать работу с приложением React.

Первый из них — использовать CDN. Это может звучать сложно, чем есть на самом деле. A CDN - [сеть доставки содержимого](https://ru.wikipedia.org/wiki/Content_Delivery_Network). У нескольких компаний есть CDN, которые публично размещают файлы, чтобы люди могли использовать их. Этими файлами могут быть библиотеки, такие как React, поскольку собранная (bundled) библиотека React — это обычный JavaScript-файл *react.js*. Он может быть размещён где-то, и вы можете использовать его в своём приложении.

Как использовать CDN для начала работы с React? Вы можете встроить его в HTML-разметку с помощью тега `<script>`, со ссылкой, которая будет указывать на URL-адрес CDN. Для начала работы с React вам нужны файла (библиотеки): *react* и *react-dom*.

{title="Code Playground",lang="javascript"}
~~~~~~~~
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
~~~~~~~~

Но почему мы должны использовать CDN, когда есть npm для установки node-пакетов, таких как React?

Когда в приложении есть файл *package.json*, вы можете установить *react* и *react-dom* из командной строки. Однако папка должна быть инициализирована как npm-проект с помощью `npm init -y` с файлом *package.json*. Вы можете установить несколько node-пакетов в одну строку через npm.

{title="Command Line",lang="text"}
~~~~~~~~
npm install react react-dom
~~~~~~~~

Этот подход часто используется для добавления React в существующее приложение, управляемое с использованием npm.

К сожалению, это ещё не всё. Вам придётся столкнуться с [Babel](http://babeljs.io/) для того, чтобы приложение могло использовать JSX (синтаксис React) и JavaScript ES6. Babel транспилирует (transpiles) ваш код так, чтобы браузеры могли интерпретировать код JavaScript ES6 и JSX, поскольку не все браузеры способны интерпретировать этот синтаксис. Эта установка включает в себя много настроек и инструментов, и для новичков в React это может быть слишком трудным, чтобы возиться со всей этой конфигурацией самостоятельно.

По этой причине Facebook представил *create-react-app* в качестве решение для быстрого запуска создания React-приложений без конфигурации (или как пишут — zero-configuration). В следующей главе будет показано, как настроить приложение, используя этот инструмент для инициализации приложения.

### Упражнения:

* узнать больше про [установку React](https://ru.react.js.org/docs/getting-started.html)

## Установка без конфигурации

В нашей книге вы будете использовать [create-react-app](https://github.com/facebookincubator/create-react-app) для начальной инициализации вашего приложения. Это самоуверенный, но с без всякой ручной конфигурации стартовый набор для React-приложений, представленный Facebook в 2016 году, и согласно опросу в Twitter [рекомендуется 96% начинающим разработчикам React](https://twitter.com/dan_abramov/status/806985854099062785). В *create-react-app* инструменты и конфигурация отходит на задний план, когда как  основное внимание уделяется реализации приложения.

Чтобы начать работу, вам требуется установить пакет в каталог глобальных node-пакетов. После этого у вас всегда есть возможность из командной строки для первоначальной настройки новых React-приложений.

{title="Command Line",lang="text"}
~~~~~~~~
npm install -g create-react-app
~~~~~~~~

Вы можете проверить версию *create-react-app*, чтобы убедиться в успешной установки из командной строки:

{title="Command Line",lang="text"}
~~~~~~~~
create-react-app --version
*v1.5.1
~~~~~~~~

Теперь вы можете инициализировать своё первое React-приложение. Мы назовём его *hackernews*, но вы можете выбрать другое имя. Весь процесс настройки займет пару секунд. После этого перейдите в папку:

{title="Command Line",lang="text"}
~~~~~~~~
create-react-app hackernews
cd hackernews
~~~~~~~~

Теперь вы можете открыть приложение в своём редакторе. Будет представлена следующая структура папок или её вариация, в зависимости от версии *create-react-app*:

{title="Folder Structure",lang="text"}
~~~~~~~~
hackernews/
  README.md
  node_modules/
  package.json
  .gitignore
  public/
    favicon.ico
    index.html
    manifest.json
  src/
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
    registerServiceWorker.js
~~~~~~~~

Ниже представлен краткий список каталогов и файлов. Это нормально, если вы не понимаете их все в самом начале.

* **README.md:** Расширение `.md` указывает, что это текстовый файл в формате Markdown. Markdown используется как лёгкий язык разметки с синтаксисом для форматирования текста. Во многих проектах с открытым исходным кодом есть файл *README.md*, чтобы дать пользователям первоначальные инструкции по проекту. Когда вы размещаете свой проект на такой платформе, как GitHub, при открытии репозитория вы увидите визуальное отображение этого файла *README.md*. Поскольку вы использовали  *create-react-app*, ваш *README.md* будет таким же, как в [GitHub-репозитории create-react-app](https://github.com/facebookincubator/create-react-app).

* **node_modules/:** В этой папке находятся все node-пакеты, которые были и будет установлены через npm. Так как вы использовали *create-react-app*, здесь должно уже быть пару установленных node-модулей. Обычно вы никогда не будете иметь дело с этим каталогом, поскольку установка и удаление node-пакетов происходит с помощью пакетных менеджеров (например, npm) из командной строки.

* **package.json:** Данный файл показывает список зависимостей node-пакетов и прочую конфигурационную информацию проекта.

* **.gitignore:** В этом файле указываются все файлы и каталоги, которые не должны быть добавлены в ваш git-репозиторий при использовании git; такие файлы будут находится только в локальном проекте. Каталог _node_modules/_ как раз является таким каталогом, который должен игнорироваться git. Достаточно, чтобы файл _package.json_ находился под git для возможности совместного использования им с вашими коллегами, чтобы они смогли самостоятельно установить все зависимости без разделения с ними папки с зависимостями.

* **public/:** Этот каталог содержит корневые файлы разработки, такие как _public/index.html_. Это индексный файл, который отображается при переходе на localhost:3000 при разработке приложения. Стандартная заготовка (boilerplate) учитывает этот файл, чтобы связать его со всеми скриптами в _src/_.

* **build/** Этот каталог будет создан при сборки проекта для продакшена. Он содержит все готовые файлы при сборке приложения для продакшен-окружения. Весь ваш код, написанный в каталогах _src/_ и _public/_, будет собран (bundled) в пару файлов при выполнении сборки проекта и будут размещены в каталоге build.

* **manifest.json** and **registerServiceWorker.js:** не обращайте внимания на эти файлы на данном этапе, нам они не понадобятся в этом проекте.

Вам не нужно трогать указанные файлы и каталоги. В самом начале всё, что вам нужно, находится в каталоге *src/*. Основное внимание уделяется файлу *src/App.js* для реализации React-компонентов. Он будет использоваться для реализации приложения, но позже вы можете разделить свои компоненты на несколько файлов, тогда как каждый файл представляет собой один или несколько компонентов.

Кроме того, вы найдёте файл *src/App.test.js* для своих тестов и *src/index.js* как точку входа (entry point) в мир React. Об этих двух файлов вы узнаете в следующей главе. Вдобавок есть файл *src/index.css* и *src/App.css* для стилизации общего приложения и ваших компонентов. У всех у них есть стили по умолчанию, если вы их откроете.

Приложение *create-react-app* — проект npm. Вы будете использовать npm для установки и удаления node-пакетов. Кроме того, вместе с ним идут npm-скрипты для выполнения в командной строке:

{title="Command Line",lang="text"}
~~~~~~~~
# Запускает приложение по адресу http://localhost:3000
npm start

# Запускает выполнение тестов
npm test

# Запускает сборку приложения для продакшена
npm run build
~~~~~~~~

Эти скрипты определены в вашем *package.json*. Теперь заготовка для React-приложения готова к работе. Следующие упражнения позволят вам, наконец, запустить, созданное приложение в браузере.

### Упражнения:

* выполнить команду `npm start` и перейти к просмотру приложения в вашем браузере (вы можете выйти из команды, завершить её, нажав на Control + C)
* запустить интерактивный скрипт `npm test`
* запустить скрипт `npm run build` и убедиться, что в проекте создался каталог *build/* (вы можете удалить его потом; обратите внимание, что каталог сборки может использоваться позже для [развёртывания приложения](https://www.robinwieruch.de/deploy-applications-digital-ocean/))
* ознакомьтесь со структурой каталогов
* ознакомьтесь с содержимым файлов
* узнать больше про [npm-скрипты и create-react-app](https://github.com/facebookincubator/create-react-app)

## Введение в JSX

Теперь вы узнаете о JSX, являющимся синтаксисом React. Как уже упоминалось ранее, *create-react-app* уже подготовил заготовку приложения для вас. Каждый файл имеет реализацию по умолчанию. Давайте погрузимся в исходный код. Единственным файлом, с которым вы в первую очередь будете работать — *src/App.js*.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h1 className="App-title">Добро пожаловать в React</h1>
        </header>
        <p className="App-intro">
          Для начала отредактируйте <code>src/App.js</code> и сохраните для перезагрузки.
        </p>
      </div>
    );
  }
}

export default App;
~~~~~~~~

Не позволяйте себе запутаться в выражениях import/export и объявлении класса. Эти возможности уже JavaScript ES6. Мы рассмотрим их в следующей главе.

В файле есть **React-компонент, определенный через класс ES6** с именем App. Это объявление компонента. В основном после того, как вы объявили компонент, вы можете использовать его в качестве элемента повсюду в своём приложении. Он будет создавать **экземпляр** вашего **компонента** или другими словами: компонент создаёт экземпляр (инстанцируется).

Возвращаемый **элемент** указывается в методе `render()`. Элементы — это то, из чего состоят компоненты. Важно понимать различия между компонентом, экземпляром и элементом.

Довольно скоро вы увидите, где создаётся экземпляр компонента App. В противном случае вы не увидите отрисованный вывод, не так ли? Компонент App — это только объявление, но не его использование. Вы должны инстанцировать компонент где-то в своём JSX с помощью `<App />`.

Содержимое в блоке render выглядит довольно похожим на HTML, но это JSX. JSX позволяет смешивать HTML и JavaScript. Он мощный, но сбивает с толку, когда вы используете его для разделения HTML и JavaScript. Вот почему хорошей отправной точкой считается использовать обычный HTML в JSX. Для начала откройте файл `App.js` и замените HTML-код на тот, который показан ниже.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <h2>Добро пожаловать в Путь к изучению React</h2>
      </div>
    );
  }
}

export default App;
~~~~~~~~

Теперь вы возвращаете только HTML из метода `render()` без всякого JavaScript. Давайте определим "Добро пожаловать в Путь к изучению React" в качестве переменной. Переменная может использоваться в JSX с использованием фигурных скобок.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

class App extends Component {
  render() {
# leanpub-start-insert
    var helloWorld = 'Добро пожаловать в Путь к изучению React';
# leanpub-end-insert
    return (
      <div className="App">
# leanpub-start-insert
        <h2>{helloWorld}</h2>
# leanpub-end-insert
      </div>
    );
  }
}

export default App;
~~~~~~~~

Он должен заработать, когда вы запустите своё приложение в командной строке с помощью команды `npm start` снова.

Кроме того, вы могли заметить атрибут `className`. Он представляет стандартный атрибут `class` в HTML. По техническим причинам JSX пришлось заменить несколько встроенных HTML-атрибутов. Вы можете найти все [поддерживаемые HTML-атрибуты в документации к React](https://ru.react.js.org/docs/dom-elements.html#all-supported-html-attributes). Они все они следует соглашению написания в camelCase. На вашем пути к изучению React, вы столкнётесь с некоторыми специфическими атрибутами JSX.

### Упражнения:

* определить больше переменные и отрисовать их в вашем JSX
  * использовать сложный объект для представления пользователя с именем и фамилией
  * отрисовать свойства пользователя в своём JSX
* более подробно ознакомиться с [JSX](https://ru.react.js.org/docs/introducing-jsx.html)
* узнать подробнее о [React-компонентах, элементах и экземпляров](https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html)

## const и let в ES6

Я думаю, вы заметили, что мы объявили переменную `helloWorld`, используя выражение `var`. В JavaScript ES6 появились два варианта для определения переменных: `const` и `let`. В JavaScript ES6 вы редко найдёте больше  использование `var`.

Переменная, объявленная с помощью `const`, не может быть повторно объявлена или изменена (они неизменяемая). Как только структура данных определена, вы не сможете её изменить.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// изменение не разрешено
const helloWorld = 'Добро пожаловать в Путь к изучению React';
helloWorld = 'Пока-пока, React';
~~~~~~~~

Переменная, объявленная с помощью `let` может быть изменена.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// изменение разрешено
let helloWorld = 'Добро пожаловать в Путь к изучению React';
helloWorld = 'Пока-пока, React';
~~~~~~~~

Вам стоит объявлять переменные через `let`, если потребуется позже повторно переназначить переменную.

Однако нужно быть аккуратнее с `const`. Переменная, объявленная с использованием `const` не может быть изменена. Но в случае если эта переменная — массив или объект, значение измениться, как обычно. Подобное значение не является неизменяемым.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// изменение разрешено
const helloWorld = {
  text: 'Добро пожаловать в Путь к изучению React'
};
helloWorld.text = 'Пока-пока, React';
~~~~~~~~

Но в каких случаях использовать тот или иной способ определения переменной? Существуют разные мнения на этот счёт. Я предлагаю использовать `const` каждый раз при определении переменной. Это будет означать, что вы хотите иметь неизменяемую структуру данных, даже несмотря на то, что значения в объектах и массивах могут изменяться. Если переменная будет изменяемой, то вы можете использовать `let`.

Неизменяемость охватывает React и его экосистему. Вот почему `const` должен быть вашим выбором по умолчанию при определении переменной. Тем не менее, в сложных объектах значения внутри могут быть изменены. Будьте осторожны с этим поведением.

В вашем приложении используйте `const` вместо `var`.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

class App extends Component {
  render() {
# leanpub-start-insert
    const helloWorld = 'Добро пожаловать в Путь к изучению React';
# leanpub-end-insert
    return (
      <div className="App">
        <h2>{helloWorld}</h2>
      </div>
    );
  }
}

export default App;
~~~~~~~~

### Упражнения:

* узнать больше о [выражении ES6 const](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/const)
* узнать больше о [выражении ES6 let](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let)
* узнайте подробнее про неизменяемые структуры данных
  * почему они вообще имеют смысл в программировании
  * почему они используются в React и его экосистеме

## ReactDOM

Прежде чем продолжить с компонентом App, возможно, вы захотите посмотреть, где он используется. Он используется в вашей точке входа в мир React: файл *src/index.js*.

{title="src/index.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

ReactDOM.render(
  <App />,
  document.getElementById('root')
);
~~~~~~~~

В основном `ReactDOM.render()` использует DOM-узел в вашей HTML-разметке для замены его вашим JSX. Вот так легко вы можете интегрировать React в любом стороннем приложении. Запрещается использовать `ReactDOM.render()` несколько раз в приложении. Вы можете использовать его в нескольких местах для начальной загрузки простого JSX-синтаксиса, React-компонента, несколько React-компонентов или всего приложения. Но в простом React-приложении вы будете использовать его только один раз для инициализации всего дерева компонентов.

`ReactDOM.render()` ожидает два аргумента. Первый аргумент — JSX, который будет отрисовываться. Второй аргумент указывает место, куда React-приложение привяжется к вашему HTML. Он ожидает элемент с `id='root'`. Вы можете открыть файл *public/index.html*, чтобы найти этот атрибут.

В текущей реализации `ReactDOM.render()` уже принимает компонент App. Тем не менее, было бы неплохо передать более простой JSX. Это необязательно должно быть инстанцирование компонента.

{title="Code Playground",lang=javascript}
~~~~~~~~
ReactDOM.render(
  <h1>Привет, мир React</h1>,
  document.getElementById('root')
);
~~~~~~~~

### Упражнения:

* открыть *public/index.html*, чтобы посмотреть где React-приложения монтируется в ваш HTML
* узнать больше об [отрисовке элементов в React](https://ru.react.js.org/docs/rendering-elements.html)

## Горячая перезагрузка

Горячая перезагрузка модулей (Hot Module Replacement, HMR) — это то, что можете сделать в файле *src/index.js* для улучшения процесса разработки в качестве разработчика. Но это не обязательно и не должно перегружать вас в начале изучения React.

По умолчанию *create-react-app* заставит обновлять страницу в браузере при изменении исходного кода. Попробуйте сами, изменив переменную `helloWorld` в файле *src/App.js*. Браузер должен обновить содержимое страницы. Но есть лучший способ сделать это.

Горячая перезагрузка модулей или замена модулей без полной перезагрузки страницы — это инструмент для перезагрузки приложения в браузере. Браузер не выполняет обновление страницы. Вы можете легко активировать его в *create-react-app*. В *src/index.js*, точке входа React, вы можете добавить следующую настройку.

{title="src/index.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

ReactDOM.render(
  <App />,
  document.getElementById('root')
);

# leanpub-start-insert
if (module.hot) {
  module.hot.accept();
}
# leanpub-end-insert
~~~~~~~~

Вот и всё. Повторите попытку изменить переменную `helloWorld` в файле *src/App.js*. Браузер не должен обновить страницу, но приложение перезагрузится и покажет корректный (актуальный) вывод. У HMR есть несколько преимуществ:

Представьте, что делаете отладку кода с использованием выражений `console.log()`. Эти выражения останутся в консоли разработчика, даже если вы изменили код, потому что браузер больше не обновляет страницу. Это может быть удобно для целей отладки.

В развивающемся приложении обновление страницы задерживает вашу продуктивность. Вы должны подождать, пока страница загрузится. Перезагрузка страницы может занять несколько секунд в большом приложении. HMR устраняет этот недостаток.

Наконец, самое большое преимущество HMR в том, что вы можете сохранить состояние после перезагрузки приложения. Представьте, что у вас есть диалоговое окно в вашем приложении с несколькими шагами, и вы находитесь на шаге 3. В целом, это напоминает мастер настройки. Без HMR вы измените исходный код, и браузер обновит страницу. Вам нужно снова открыть диалоговое окно и перейти с шана 1 на шаг 3. С использованием HMR диалоговое окно остаётся открытым на шаге 3. Он сохраняет состояние приложения, даже если исходный код изменяется. Перезагружается только само приложение, а не страница.

### Упражнения:

* измените исходный код *src/App.js* несколько раз, чтобы увидеть работу HMR в действии
* посмотреть первые 10 минут видео (на английском) Дэна Абрамова (Dan Abramov) [Live React: Hot Reloading with Time Travel](https://www.youtube.com/watch?v=xsSnOQynTHs)

## Комплексный JavaScript в JSX

Вернёмся в нашему компоненту App. До сих пор вы отрисовывали некоторые примитивные переменные в вашем JSX. Теперь вы начнёте отрисовывать список элементов. Список будет состоят из демонстрационных данных в начале, но позже данные вы будете получать из внешнего [API](https://www.robinwieruch.de/what-is-an-api-javascript/), что будет намного интереснее.

Сначала определим список элементов.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

# leanpub-start-insert
const list = [
  {
    title: 'React',
    url: 'https://facebook.github.io/react/',
    author: 'Jordan Walke',
    num_comments: 3,
    points: 4,
    objectID: 0,
  },
  {
    title: 'Redux',
    url: 'https://github.com/reactjs/redux',
    author: 'Dan Abramov, Andrew Clark',
    num_comments: 2,
    points: 5,
    objectID: 1,
  },
];
# leanpub-end-insert

class App extends Component {
  ...
}
~~~~~~~~

Демо-данные представляют данные, которые будут получены позже из API. У элемента в списке есть заголовок, ссылка и автор. Кроме того, он содержит идентификатор, баллы (которые указывают, насколько популярна статья) и количество комментариев.

Теперь вы можете использовать встроенную функцию JavaScript `map` в JSX. Она позволяет вам перебирать список элементов для их отображения. Снова вы будете использовать фигурные скобки для вставки (инкапсуляции) JavaScript-выражений в вашем JSX.

{title="src/App.js",lang=javascript}
~~~~~~~~
class App extends Component {
  render() {
    return (
      <div className="App">
# leanpub-start-insert
        {list.map(function (item) {
          return <div>{item.title}</div>;
        })}
# leanpub-end-insert
      </div>
    );
  }
}

export default App;
~~~~~~~~

Использование JavaScript вместе с HTML очень эффективно в JSX. Вы могли использовать `map` для преобразования одного списка элементов список элементов. Но на этот раз вы можете использовать `map` для преобразования списка элементов в HTML-элементы.

Пока что для каждого элемента отображается `title`. Давайте отобразим ещё больше свойств элементов.

{title="src/App.js",lang=javascript}
~~~~~~~~
class App extends Component {
  render() {
    return (
      <div className="App">
# leanpub-start-insert
        {list.map(function (item) {
          return (
            <div>
              <span>
                <a href={item.url}>{item.title}</a>
              </span>
              <span>{item.author}</span>
              <span>{item.num_comments}</span>
              <span>{item.points}</span>
            </div>
          );
        })}
# leanpub-end-insert
      </div>
    );
  }
}

export default App;
~~~~~~~~

Вы можете увидеть, что функция `map` просто встроена в ваш JSX. Каждое свойство элемента отображается в теге `<span>`. Кроме того, свойство url элемента используется в атрибуте `href` тега якоря.

React выполнит всю работу за вас и отобразит каждый элемент, но вы должны добавить одного помощника для React, чтобы полностью использовать его потенциал и улучшить его производительность. Вы должны назначить атрибут ключа каждому элементу списка. Таким образом, React может идентифицировать добавленные, изменённые и удалённые элементы при изменении списка. У элементов списка демо-данных уже есть идентификатор.

{title="src/App.js",lang=javascript}
~~~~~~~~
{list.map(function (item) {
  return (
# leanpub-start-insert
    <div key={item.objectID}>
# leanpub-end-insert
      <span>
        <a href={item.url}>{item.title}</a>
      </span>
      <span>{item.author}</span>
      <span>{item.num_comments}</span>
      <span>{item.points}</span>
    </div>
  );
})}
~~~~~~~~

Вы должны убедиться, что атрибут key — уникальный идентификатор. Не допускайте ошибку, использовав индекс элемента в массиве. Индекс массива вообще непостоянный. Например, когда список изменяет свой порядок, React будет трудно идентифицировать элементы правильно.

{title="src/App.js",lang=javascript}
~~~~~~~~
// не делайте так
{list.map(function (item, key) {
  return (
    <div key={key}>
      ...
    </div>
  );
})}
~~~~~~~~

Теперь вы отображаете оба списка. Вы можете запустить приложение, открыть браузер и увидеть оба элемента списка.

### Упражнения:

* узнать подробнее о [списках и ключах React](https://ru.react.js.org/docs/lists-and-keys.html)
* повторить [стандартные встроенные функции массива в JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
* использовать больше JavaScript-выражений в JSX

## Стрелочные функции ES6

JavaScript ES6 представил стрелочные функции (arrow functions). Выражение стрелочной функции короче функциональных выражений.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// объявление функции
function () { ... }

// объявление стрелочной функции
() => { ... }
~~~~~~~~

Вам необходимо знать о функциональности стрелочных функций. Одна из их возможностей — это другое поведение с объектом `this`. Функция всегда определяет свой собственный объект `this`. У стрелочной функции по-прежнему есть объект `this` из окружающего контекста.

Есть ещё один ценный факт о стрелочных функций относительно круглых скобок. Вы можете удалить круглые скобки, когда функция принимает только один аргумент, но их нужно оставить в случае, если стрелочная функция принимает несколько аргументов.

{title="Code Playground",lang="javascript"}
~~~~~~~~
// разрешено
item => { ... }

// разрешено
(item) => { ... }

// не разрешено
item, key => { ... }

// разрешено
(item, key) => { ... }
~~~~~~~~

Давайте посмотрим на функцию `map`. Вы можете написать её более кратко с помощью стрелочных функций из ES6.

{title="src/App.js",lang=javascript}
~~~~~~~~
# leanpub-start-insert
{list.map(item => {
# leanpub-end-insert
  return (
    <div key={item.objectID}>
      <span>
        <a href={item.url}>{item.title}</a>
      </span>
      <span>{item.author}</span>
      <span>{item.num_comments}</span>
      <span>{item.points}</span>
    </div>
  );
})}
~~~~~~~~

Кроме того, вы можете удалить *тело блока*, то есть фигурные скобки стрелочной функции ES6. В *сокращённом теле блока* подразумевается неявный возврат. Таким образом, вы можете удалить выражение `return`. Такая форма стрелочной функции в книге будет использоваться чаще, поэтому убедитесь, что понимаете разницу между телом блока и сокращённым телом блока при использовании стрелочных функций.

{title="src/App.js",lang=javascript}
~~~~~~~~
# leanpub-start-insert
{list.map(item =>
# leanpub-end-insert
  <div key={item.objectID}>
    <span>
      <a href={item.url}>{item.title}</a>
    </span>
    <span>{item.author}</span>
    <span>{item.num_comments}</span>
    <span>{item.points}</span>
  </div>
# leanpub-start-insert
)}
# leanpub-end-insert
~~~~~~~~

Теперь ваш JSX выглядит более кратким и читаемым. В нём нет выражение `function`, фигурных скобок и выражения `return`. Вместо это разработчик может сосредоточиться на деталях реализации.

### Упражнения:

* прочитать подробнее о [стрелочных функциях ES6](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

## Классы ES6

JavaScript ES6 представил классы. Класс обычно используется в объектно-ориентированных языках программирования. JavaScript был и есть очень гибкий в своих парадигмах программирования. Вы можете использовать функциональное программирование и объектно-ориентированное программирование бок о бок, в зависимости от конкретных случаях использования.

Несмотря на то, что React охватывает функциональное программирование, например, с неизменяемыми структурами данных, классы используются для объявления компонентов. Они называются компонентами класса ES6 или классовыми компонентами ES6. React смешивает хорошие части этих обеих парадигм программирования.

Давайте рассмотрим следующий класс Developer для изучения класса JavaScript ES6, не думая о компоненте.

{title="Code Playground",lang="javascript"}
~~~~~~~~
class Developer {
  constructor(firstname, lastname) {
    this.firstname = firstname;
    this.lastname = lastname;
  }

  getName() {
    return this.firstname + ' ' + this.lastname;
  }
}
~~~~~~~~

У класса есть конструктор, чтобы сделать его инстанцируемым (создать из него объект). Конструктор может принимать аргументы, чтобы их можно назначить экземпляру класса. Кроме того, класс может определять функции. Поскольку функция связана с классом, она называется методом. Часто он упоминается как метод класса.

Класс Developer — это только объявление класса. Вы можете создать несколько экземпляров класса путём вызова его. Он похож на компонент класса ES6, который имеет объявление, но вы должны использовать его в другом месте для создания экземпляра.

Давайте посмотрим, как вы можете создать экземпляр класса и как использовать его методы.

{title="Code Playground",lang="javascript"}
~~~~~~~~
const robin = new Developer('Robin', 'Wieruch');
console.log(robin.getName());
// выведет: Robin Wieruch
~~~~~~~~

React использует классы JavaScript ES6 для компонентов классов ES6. Вы уже использовали один компонент класса ES6.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';

...

class App extends Component {
  render() {
    ...
  }
}
~~~~~~~~

Класс App наследует `Component`. В основном, когда вы объявляете компонент App, он наследуется от другого компонента. Что значит "наследуется"? В объектно-ориентированном программировании у вас есть принцип наследования, который означает, что функциональные возможности могут передаваться из одного класса в другой.

Класс App наследует функциональность из класса Component. Более конкретно — он наследует функциональность из класса Component. Класс Component используются для наследования базового класса ES6 в класс компонента ES6. Он имеет всю функциональность, которую компонент в React имеет. Метод render - одна из тех функциональностей, которые вы уже использовали. В дальнейшем вы узнаете о других методах класса компонента.

Класс `Component` инкапсулирует все детали реализации компонента React. Это позволяет разработчикам использовать классы как компоненты в React.

Методы, предоставляемые компонентом `Component`, являются открытым интерфейсом. Один из этих методов должен быть переопределён, другие не должны быть переопределены. Вы узнаете о последних методов, когда в этой книге будут рассматриваться методы жизненного цикла в последней главе. Метод `render()` должен быть переопределён, поскольку он определяет вывод компонента React `Component`. Поэтому он должен быть переопределён.

В данный момент вы узнали о основах классах JavaScript ES6 и то, как они используются в React для создания компонентов. Вы узнаете подробнее о методах Component, когда в книге будут описаны методы жизненного цикла React.

### Упражнения:

* узнать подробнее о [классах ES6](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)

{pagebreak}

Вы научились создавать своё собственное React-приложение! Давайте вспомним последние темы:

* React
  * create-react-app для создания заготовки приложения React
  * JSX смешивает HTML и JavaScript для определения вывода React-компонентов в своих методах render
  * компоненты, экземпляры и элементы — разные вещи в React
  * `ReactDOM.render()` — это точка входа для React-приложения, которая привязывает React к DOM
  * встроенная функциональность JavaScript может использоваться в JSX
    * map можно использовать для отрисовки списка элементов как HTML-элементы
* ES6
  * объявления переменных с помощью `const` и `let` могут использоваться в зависимости от конкретных случаев
    * использование `const` вместо `let` в React-приложений
  * стрелочные функции используются для краткого написания ваших функций
  * классы используются для определения компонентов в React путём их наследования

Имеет смысл сделать перерыв на данном этапе. Усвоить полученные знания и применить их на практике самостоятельно. Вы можете поэкспериментировать с исходным кодом, написанным в рамках этой главы. Его можно найти в [официальном репозитории](https://github.com/the-road-to-learn-react/hackernews-client/tree/5.1).
